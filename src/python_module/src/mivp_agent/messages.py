from threading import Lock

from mivp_agent.const import KEY_ID
from mivp_agent.const import KEY_EPISODE_MGR_REPORT, KEY_EPISODE_MGR_STATE
from mivp_agent.util.validate import validateAction
from mivp_agent.util.parse import parse_report

INSTR_SEND_STATE = {
    'speed': 0.0,
    'course': 0.0,
    'posts': {},
    'ctrl_msg': 'SEND_STATE'
}
INSTR_START = {
    'speed': 0.0,
    'course': 0.0,
    'posts': {
        'EPISODE_MGR_CTRL': 'type=start'
    },
    'ctrl_msg': 'SEND_STATE'
}
INSTR_PAUSE = {
    'speed': 0.0,
    'course': 0.0,
    'posts': {
        'EPISODE_MGR_CTRL': 'type=pause'
    },
    'ctrl_msg': 'SEND_STATE'
}
INSTR_STOP = {
    'speed': 0.0,
    'course': 0.0,
    'posts': {
        'EPISODE_MGR_CTRL': 'type=hardstop'
    },
    'ctrl_msg': 'SEND_STATE'
}
INSTR_RESET_SUCCESS = {
    'speed': 0.0,
    'course': 0.0,
    'posts': {
        'EPISODE_MGR_CTRL': 'type=reset,success=true'
    },
    'ctrl_msg': 'SEND_STATE'
}
INSTR_RESET_FAILURE = {
    'speed': 0.0,
    'course': 0.0,
    'posts': {
        'EPISODE_MGR_CTRL': 'type=reset,success=false'
    },
    'ctrl_msg': 'SEND_STATE'
}

class MissionMessage:
    '''
    This class is used to parse incoming messages into attributes (see below) and provide a simple interface for responding to each message.

    **IMPORTANT NOTE:** Messages **MUST** be responded by one of the following methods to as `BHV_Agent` will not send another update until it has a response to the last.

      - [`act(action)`][mivp_agent.manager.MissionMessage.act] **<---- Most common**
      - [`request_new()`][mivp_agent.manager.MissionMessage.request_new]
      - [`start()`][mivp_agent.manager.MissionMessage.start]
      - [`pause()`][mivp_agent.manager.MissionMessage.pause]
      - [`stop()`][mivp_agent.manager.MissionMessage.stop]

    Attributes:
      vname (str): The vehicle's name which generated the message.
      state (dict): A dictionary containing key, value pairs of MOOS vars and their associated value at the time the message was created by `BHV_Agent`.
      episode_report (dict or None): If `pEpisodeManager` is present on the vehicle this message will contain any "report" generated by it at the end of episodes. If no `pEpisodeManager` is present, the **value will be** `None`.
      episode_state (str or None): If `pEpisodeManager` is present on the vehicle this message will be the state which that app is broadcasting. Otherwise, it will be `None`.

    '''

    def __init__(self, addr, msg, is_transition=True):
        # For use my MissionManager
        self._addr = addr
        self._response = None
        self._rsp_lock = Lock()

        # For use by client
        self.state = msg
        self.vname = msg[KEY_ID]
        self.episode_report = self.state[KEY_EPISODE_MGR_REPORT]
        self.episode_state = None
        if self.state[KEY_EPISODE_MGR_STATE] is not None:
            self.episode_state = self.state[KEY_EPISODE_MGR_STATE]
        
        # For use by logger
        self._is_transition = is_transition

    def _assert_no_rsp(self):
        assert self._response is None, 'This message has already been responded to'

    def mark_transition(self):
        with self._rsp_lock:
            assert self._response is None, "A message's state can only be marked at a transition before a response to that message has been set."

            self._is_transition = True

    def act(self, action):
        '''
        This is used to send an action for the `BHV_Agent` to execute.

        Args:
          action (dict): An action to send (see below)

        Example:
          Actions submitted through `MissionMessage` are python dictionaries with the following **required** fields.
          ```
          msg.act({
              'speed': 1.0
              'course': 180.0
          })
          ```
        Example:
          Optionally, one can add a MOOS var and value they would like to post.
          ```
          msg.act({
              'speed': 0.0
              'course': 0.0
              'posts': {
                'ACTION': 'ATTACK_LEFT'
              },
          })
          ``` 
        '''
        self._assert_no_rsp()
        # Copy so we don't run into threading errors if client reuses the action dict
        instr = action.copy()
        if 'posts' not in action:
            instr['posts'] = {}
        validateAction(instr)
        instr['ctrl_msg'] = 'SEND_STATE'

        with self._rsp_lock:
            self._response = instr

    def start(self):
        '''
        This method is used to send a message to `pEpisodeManager` to **start** an episode. The following message will be constructed and dispatched.

        ```
        {
          'speed': 0.0,
          'course': 0.0,
          'posts': {
            'EPISODE_MGR_CTRL': 'type=start'
          },
        }
        ```
        '''
        self._assert_no_rsp()
        with self._rsp_lock:
            self._response = INSTR_START

    def pause(self):
        '''
        This method is used to send a message to `pEpisodeManager` to **pause** after the current episode. The following messagewill be constructed and dispatched.

        ```
        {
          'speed': 0.0,
          'course': 0.0,
          'posts': {
            'EPISODE_MGR_CTRL': 'type=pause'
          },
        }
        ```
        '''
        self._assert_no_rsp()
        with self._rsp_lock:
            self._response = INSTR_PAUSE

    def stop(self):
        '''
        This method is used to send a message to `pEpisodeManager` to **hardstop** an episode immediately. The following messagewill be constructed and dispatched.

        ```
        {
          'speed': 0.0,
          'course': 0.0,
          'posts': {
            'EPISODE_MGR_CTRL': 'type=hardstop'
          },
        }
        ```
        '''
        self._assert_no_rsp()

        with self._rsp_lock:
            self._response = INSTR_STOP

    def request_new(self):
        '''
        This method is used to send ask `BHV_Agent` to send another action.
        '''
        self._assert_no_rsp()

        with self._rsp_lock:
            self._response = INSTR_SEND_STATE
